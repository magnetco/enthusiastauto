<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>6</epicId>
    <storyId>6.1</storyId>
    <title>Unified Search Infrastructure</title>
    <status>Draft</status>
    <generatedAt>2025-10-23</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-6.1.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>a unified search system that queries both Sanity (vehicles) and Shopify (parts) and returns ranked results</iWant>
    <soThat>users can search across the entire platform from a single search interface</soThat>
    <tasks>
      <task id="1" acs="1,3,7">Install and configure Fuse.js with field weighting and fuzzy matching configuration</task>
      <task id="2" acs="1,2,8">Create unified search orchestration service merging Sanity and Shopify results</task>
      <task id="3" acs="1,5">Implement search data indexing with 15-minute cache TTL</task>
      <task id="4" acs="4,6">Add performance optimization and caching with fallback handling</task>
      <task id="5" acs="1,4">Create search API route with rate limiting and validation</task>
      <task id="6" acs="5">Integrate webhook handlers for index updates</task>
      <task id="7" acs="8">Add TypeScript types and interfaces for search system</task>
      <task id="8" acs="1,2,3,4">Write unit tests for search functionality</task>
      <task id="9" acs="7">Document search architecture and usage</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1" priority="critical">Search Index Integration - Search system indexes both vehicles (Sanity) and parts (Shopify) in a unified searchable format</criterion>
    <criterion id="2" priority="high">Relevance Ranking - Results ranked by relevance with configurable weights (exact match > partial match > metadata)</criterion>
    <criterion id="3" priority="high">Fuzzy Matching - Search supports fuzzy matching for typos and partial queries with configurable thresholds</criterion>
    <criterion id="4" priority="critical">Performance Target - Search queries return results within 300ms for 95th percentile (NFR009 compliance)</criterion>
    <criterion id="5" priority="high">Real-Time Index Updates - Indexes update within 15 minutes of content changes in either Sanity or Shopify (NFR008)</criterion>
    <criterion id="6" priority="medium">Fallback Handling - System gracefully handles search service unavailability with cached fallback</criterion>
    <criterion id="7" priority="medium">Field Weighting - Search configuration allows weighting different fields (title, description, tags, SKU, VIN) for relevance</criterion>
    <criterion id="8" priority="high">Result Format - Search returns unified result objects with type discrimination (vehicle vs part) and consistent structure</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/PRD.md" title="Product Requirements Document">
        <section name="Epic 6: Advanced Search &amp; Discovery">Goal: Enable intelligent unified search across vehicles and parts with recommendation engine. Stories cover unified search implementation, search indexing, recommendation algorithm. Key Capabilities: Unified search bar returning results from both Sanity (vehicles) and Shopify (parts), search result filtering by content type, fuzzy matching and autocomplete suggestions.</section>
        <section name="FR019 - Unified Search Requirement">The system shall provide a unified search experience that returns results from both vehicle inventory and parts catalog.</section>
        <section name="NFR009: Search &amp; Discovery Performance">Unified search queries shall return results within 300ms for 95th percentile of requests. Search results shall rank by relevance using configurable weights (exact match, partial match, metadata). Search shall support fuzzy matching for misspellings and partial queries.</section>
      </doc>
      <doc path="docs/epic-stories.md" title="Epic Breakdown">
        <section name="Epic 6 Overview">Epic 6: Advanced Search &amp; Discovery (Phase 2). Goal: Enable intelligent unified search across vehicles and parts with recommendation engine and cross-discovery features. Priority: Should Have - Key differentiator for unified platform. Estimated Duration: 3-4 sprints. Dependencies: Epic 3 (vehicles), Epic 1 (parts), search infrastructure decision.</section>
        <section name="Story 6.1: Unified Search Infrastructure">As a developer I want a unified search system that queries both Sanity and Shopify so that users can search vehicles and parts in one place. AC: Search index includes both vehicles and parts, results ranked by relevance, fuzzy matching for typos, performance &lt;300ms for 95th percentile, indexes update within 15 minutes, field weighting configuration, fallback to basic search. Effort: 13 points (complex infrastructure decision).</section>
      </doc>
      <doc path="docs/solution-architecture.md" title="Solution Architecture Document - Phase 2">
        <section name="ADR-005: Client-Side Search (Fuse.js) First, Meilisearch Later">Decision: Start with free client-side search, upgrade when needed. Rationale: Fuse.js free, Meilisearch $0-29/mo. Scale: MVP inventory &lt;500 items, client-side sufficient. Upgrade Path: Clear migration to Meilisearch when &gt;200 items or &lt;300ms latency needed. NFR009 Compliance: Client-side meets &lt;300ms for initial scale. Trade-offs: Zero cost for MVP, sufficient for launch. Migration effort when upgrading (acceptable, planned).</section>
        <section name="Technology Stack - Search Technologies">Search (Phase 2a): Fuse.js 7.0.0 - Client-side fuzzy search, zero cost, sufficient for MVP scale (&lt;500 items), instant filtering UX. Search (Phase 2b): Meilisearch Cloud (future) - Upgrade path when inventory exceeds 200 items, &lt;300ms search (NFR009), typo tolerance, free tier 100k docs.</section>
        <section name="Business Logic Layer - Search Service">Search Service - Unified search orchestration, Fuse.js integration.</section>
        <section name="File Structure - lib/search/">lib/search/ directory contains: unified.ts (unified search orchestration), fuse.ts (Fuse.js client-side search), recommendations.ts (cross-discovery logic).</section>
      </doc>
      <doc path="docs/tech-specs/epic-3-vehicle-inventory-tech-spec.md" title="Technical Specification: Epic 3 - Vehicle Inventory Integration">
        <section name="Sanity Client Configuration">Sanity client config pattern: projectId from env, dataset from env, apiVersion 2024-10-21, useCdn: false for fresh data (ISR handles caching). This integration pattern will be used by search to query Sanity vehicles.</section>
      </doc>
    </docs>
    <code>
      <artifact path="lib/sanity/queries/vehicles.ts" kind="service" symbol="getVehicles, VehicleListItem, VehicleDetail" reason="Core vehicle query function with filtering/sorting. Search should use these types and extend query functions for search-specific needs."/>
      <artifact path="sanity/lib/client.ts" kind="client" symbol="client (read-only)" reason="Search service should use read-only Sanity client for querying vehicle data."/>
      <artifact path="sanity/schemas/vehicle.ts" kind="schema" symbol="vehicle schema definition" reason="Defines searchable fields (listingTitle, overview, highlights, history, chassis, bodyStyle) for vehicle index."/>
      <artifact path="lib/shopify/index.ts" kind="service" symbol="shopifyFetch, getProducts, revalidate" reason="Core Shopify API integration. getProducts() accepts search query parameter. revalidate() should trigger search index refresh."/>
      <artifact path="lib/shopify/types.ts" kind="types" symbol="Product, ShopifyProduct" reason="Product data structures for search results. Index should include title, description, vendor, productType, tags fields."/>
      <artifact path="lib/shopify/queries/product.ts" kind="query" symbol="getProductsQuery" reason="GraphQL query already supports Shopify search query parameter for product search integration."/>
      <artifact path="lib/cache/memory.ts" kind="utility" symbol="MemoryCache class, memoryCache instance" reason="In-memory cache with TTL (5 min default). Search results should use this utility following recommendations pattern."/>
      <artifact path="lib/shared/recommendations.ts" kind="service" symbol="getCompatibleParts, rankProductForVehicle, parseFitmentTag" reason="Reference implementation for cross-platform queries (Sanity + Shopify), caching patterns, and relevance ranking algorithms."/>
      <artifact path="app/api/revalidate/vehicle/[slug]/route.ts" kind="webhook" symbol="POST handler" reason="Sanity webhook for vehicle updates. Search index should refresh when vehicles are modified."/>
      <artifact path="lib/types/filters.ts" kind="types" symbol="FilterState, searchTerm" reason="Existing filter types include searchTerm field. Search filters should integrate with this state."/>
    </code>
    <dependencies>
      <node>
        <toInstall>
          <package name="fuse.js" version="^7.0.0" purpose="Client-side fuzzy search library for unified search (ADR-005)"/>
        </toInstall>
        <existing>
          <package name="next" version="15.3.0-canary.13" purpose="Next.js framework for API routes and server components"/>
          <package name="react" version="19.0.0" purpose="React library for UI components"/>
          <package name="@sanity/client" version="^7.12.0" purpose="Sanity CMS client for vehicle queries"/>
          <package name="next-sanity" version="11" purpose="Sanity integration for Next.js"/>
          <package name="typescript" version="5.8.2" purpose="TypeScript for type safety in search types"/>
          <package name="vitest" version="^4.0.1" purpose="Testing framework for unit tests"/>
          <package name="@testing-library/react" version="^16.3.0" purpose="React testing utilities"/>
        </existing>
      </node>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="architecture">Follow existing cross-platform query pattern from lib/shared/recommendations.ts (separate queries merged with ranking)</constraint>
    <constraint type="architecture">Use lib/cache/memory.ts MemoryCache for result caching with 5-minute TTL (NFR009 compliance)</constraint>
    <constraint type="architecture">Place search logic in lib/search/ directory per ADR-005 and solution architecture file structure</constraint>
    <constraint type="architecture">Create lib/search/unified.ts (orchestration), lib/search/fuse.ts (config), lib/search/indexer.ts (caching) per architecture spec</constraint>
    <constraint type="performance">Search queries must return results within 300ms for 95th percentile (NFR009 critical requirement)</constraint>
    <constraint type="performance">Index refresh within 15 minutes of content changes (NFR008 requirement)</constraint>
    <constraint type="performance">Implement cache warming for popular search terms (BMW, E46, M3, parts)</constraint>
    <constraint type="integration">Use existing Sanity client from sanity/lib/client.ts (read-only client for queries)</constraint>
    <constraint type="integration">Use existing Shopify getProducts() function with query parameter from lib/shopify/index.ts</constraint>
    <constraint type="integration">Extend webhook handlers (app/api/revalidate/vehicle and lib/shopify/revalidate) to trigger search index refresh</constraint>
    <constraint type="types">Reuse VehicleListItem and Product types for search result consistency</constraint>
    <constraint type="types">Create unified SearchResult type with type discrimination (vehicle vs product) per AC8</constraint>
    <constraint type="search">Configure Fuse.js threshold at 0.3 for balanced precision/recall per story tasks</constraint>
    <constraint type="search">Field weighting: title 2.0, tags 1.5, description 1.0, metadata 0.8 per story configuration</constraint>
    <constraint type="search">Vehicle searchable fields: title, year, make, model, VIN, price, description per sanity schema</constraint>
    <constraint type="search">Product searchable fields: title, handle, vendor, tags, price, description per shopify types</constraint>
    <constraint type="error-handling">Implement graceful fallback to cached results if index rebuild fails (AC6)</constraint>
    <constraint type="security">Add rate limiting (100 requests/min per IP) on search API endpoint per story tasks</constraint>
    <constraint type="testing">Unit tests with Vitest following existing pattern. Mock Sanity/Shopify clients.</constraint>
    <constraint type="testing">Performance tests must validate &lt;300ms latency with 100+ items dataset</constraint>
  </constraints>
  <interfaces>
    <interface name="SearchResult&lt;T&gt;" kind="TypeScript type" signature="{ type: 'vehicle' | 'product', item: T, score: number }" path="types/search.ts">Unified result object with type discrimination per AC8</interface>
    <interface name="SearchQuery" kind="TypeScript interface" signature="{ q: string, type?: 'vehicles' | 'parts' | 'all', limit?: number }" path="types/search.ts">Search query parameters for API</interface>
    <interface name="SearchResponse" kind="TypeScript interface" signature="{ results: SearchResult[], totalResults: number, searchTime: number }" path="types/search.ts">API response format</interface>
    <interface name="SearchableVehicle" kind="TypeScript type" signature="Flat object with searchable fields from VehicleListItem" path="types/search.ts">Fuse.js-compatible vehicle format</interface>
    <interface name="SearchableProduct" kind="TypeScript type" signature="Flat object with searchable fields from Product" path="types/search.ts">Fuse.js-compatible product format</interface>
    <interface name="searchAll(query: string)" kind="Function" signature="(query: string) => Promise&lt;SearchResult[]&gt;" path="lib/search/unified.ts">Main orchestration function querying both CMSs</interface>
    <interface name="GET /api/search" kind="REST endpoint" signature="GET /api/search?q=string&amp;type=vehicles|parts|all&amp;limit=number" path="app/api/search/route.ts">Public search API endpoint with rate limiting</interface>
    <interface name="VehicleListItem" kind="TypeScript interface" signature="Existing type from lib/sanity/queries/vehicles.ts" path="lib/sanity/queries/vehicles.ts">Reuse for vehicle search results</interface>
    <interface name="Product" kind="TypeScript type" signature="Existing type from lib/shopify/types.ts" path="lib/shopify/types.ts">Reuse for product search results</interface>
  </interfaces>
  <tests>
    <standards>Use Vitest v4.0.1 for unit tests with happy-dom environment. Follow existing pattern from lib/shared/__tests__/recommendations.test.ts: mock dependencies (vi.mock for Sanity client, Shopify fetch, cache), use describe/it/expect structure, mock external services. Test files located in __tests__ subdirectories. Coverage tracked with v8 provider. Run tests with npm test, watch mode with npm run test:watch. Mock pattern: vi.mock('@/lib/shopify'), vi.mock('@/sanity/lib/client'), vi.mock('@/lib/cache/memory').</standards>
    <locations>
      <location>lib/search/__tests__/</location>
      <location>lib/search/__tests__/unified.test.ts</location>
      <location>lib/search/__tests__/fuse.test.ts</location>
      <location>lib/search/__tests__/indexer.test.ts</location>
      <location>app/api/search/__tests__/route.test.ts</location>
    </locations>
    <ideas>
      <idea ac="1">Test Fuse.js configuration with sample vehicle data (5 vehicles with various makes/models/years)</idea>
      <idea ac="1">Test Fuse.js configuration with sample product data (5 parts with various vendors/tags/titles)</idea>
      <idea ac="1,2,8">Test unified search orchestration merges vehicle and product results correctly into SearchResult[] array</idea>
      <idea ac="2">Test relevance scoring ranks exact title matches higher than partial matches</idea>
      <idea ac="2">Test relevance scoring ranks partial matches higher than metadata matches</idea>
      <idea ac="2">Test configurable field weights (title 2.0, tags 1.5, description 1.0) affect ranking order</idea>
      <idea ac="3">Test fuzzy matching handles typos: 'BNW' finds 'BMW' results</idea>
      <idea ac="3">Test fuzzy matching handles typos: 'E64' finds 'E46' results</idea>
      <idea ac="3">Test fuzzy matching with threshold 0.3 balances precision and recall</idea>
      <idea ac="3">Test partial queries: 'M3' matches '2006 BMW M3', 'M3 Carbon Fiber Spoiler'</idea>
      <idea ac="4">Test search performance meets &lt;300ms target with 100 vehicles + 100 products dataset</idea>
      <idea ac="4">Test search performance with various query lengths (2 chars, 10 chars, 50 chars)</idea>
      <idea ac="4">Test cache hit performance is faster than cache miss</idea>
      <idea ac="5">Test index builder fetches all vehicles from Sanity (mock client.fetch)</idea>
      <idea ac="5">Test index builder fetches all products from Shopify (mock shopifyFetch)</idea>
      <idea ac="5">Test index refresh updates cached indexes after TTL expiration (15 min)</idea>
      <idea ac="5">Test cache invalidation after TTL returns fresh data on next query</idea>
      <idea ac="6">Test fallback to cached results when Sanity client throws error</idea>
      <idea ac="6">Test fallback to cached results when Shopify fetch throws error</idea>
      <idea ac="6">Test graceful degradation returns empty array when no cache and service unavailable</idea>
      <idea ac="7">Test field weighting configuration for vehicles (title, VIN, description, chassis)</idea>
      <idea ac="7">Test field weighting configuration for products (title, handle, vendor, tags)</idea>
      <idea ac="8">Test SearchResult type discrimination: vehicle results have type='vehicle'</idea>
      <idea ac="8">Test SearchResult type discrimination: product results have type='product'</idea>
      <idea ac="8">Test unified result structure includes item, score, and type fields</idea>
      <idea ac="8">Test API response format matches SearchResponse interface (results, totalResults, searchTime)</idea>
      <idea ac="1,4">Test API route validates query input (min 2 chars, max 100 chars)</idea>
      <idea ac="1,4">Test API route returns 400 for invalid query (empty string, too long)</idea>
      <idea ac="1,4">Test API route accepts type parameter filtering (vehicles, parts, all)</idea>
      <idea ac="1,4">Test API route respects limit parameter (default 20, max 100)</idea>
    </ideas>
  </tests>
</story-context>
